'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var path = require('path');
var util = require('util');
var fs = require('fs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

const readFile = util.promisify(fs__default["default"].readFile);
const toLowerCase = (str) => str.toLowerCase();
const dashToPascalCase = (str) => toLowerCase(str)
    .split("-")
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join("");
function sortBy(array, prop) {
    return array.slice().sort((a, b) => {
        const nameA = prop(a);
        const nameB = prop(b);
        if (nameA < nameB)
            return -1;
        if (nameA > nameB)
            return 1;
        return 0;
    });
}
function normalizePath(str) {
    // Convert Windows backslash paths to slash paths: foo\\bar âž” foo/bar
    // https://github.com/sindresorhus/slash MIT
    // By Sindre Sorhus
    if (typeof str !== "string") {
        throw new Error(`invalid path to normalize`);
    }
    str = str.trim();
    if (EXTENDED_PATH_REGEX.test(str) || NON_ASCII_REGEX.test(str)) {
        return str;
    }
    str = str.replace(SLASH_REGEX, "/");
    // always remove the trailing /
    // this makes our file cache look ups consistent
    if (str.charAt(str.length - 1) === "/") {
        const colonIndex = str.indexOf(":");
        if (colonIndex > -1) {
            if (colonIndex < str.length - 2) {
                str = str.substring(0, str.length - 1);
            }
        }
        else if (str.length > 1) {
            str = str.substring(0, str.length - 1);
        }
    }
    return str;
}
function relativeImport(pathFrom, pathTo, ext) {
    let relativePath = path__default["default"].relative(path__default["default"].dirname(pathFrom), path__default["default"].dirname(pathTo));
    if (relativePath === "") {
        relativePath = ".";
    }
    else if (relativePath[0] !== ".") {
        relativePath = "./" + relativePath;
    }
    return normalizePath(`${relativePath}/${path__default["default"].basename(pathTo, ext)}`);
}
async function readPackageJson(rootDir) {
    const pkgJsonPath = path__default["default"].join(rootDir, "package.json");
    let pkgJson;
    try {
        pkgJson = await readFile(pkgJsonPath, "utf8");
    }
    catch (e) {
        throw new Error(`Missing "package.json" file for distribution: ${pkgJsonPath}`);
    }
    let pkgData;
    try {
        pkgData = JSON.parse(pkgJson);
    }
    catch (e) {
        throw new Error(`Error parsing package.json: ${pkgJsonPath}, ${e}`);
    }
    return pkgData;
}
const EXTENDED_PATH_REGEX = /^\\\\\?\\/;
const NON_ASCII_REGEX = /[^\x00-\x80]+/;
const SLASH_REGEX = /\\/g;

const createComponentDefinition = (importTypes, componentModelConfigs) => (cmpMeta) => {
    const tagNameAsPascal = dashToPascalCase(cmpMeta.tagName);
    let props = '';
    let model = '';
    let methods = '';
    if (Array.isArray(cmpMeta.properties) && cmpMeta.properties.length > 0) {
        const relevantPropsConfig = cmpMeta.properties
            .map((prop) => `    ${prop.name}: {} as PropOptions<${importTypes}.${tagNameAsPascal}['${prop.name}']>,`)
            .join('\n');
        props = `
  props: {
${relevantPropsConfig}
  },`;
    }
    if (Array.isArray(componentModelConfigs)) {
        const relevantModelConfig = componentModelConfigs.find((modelConfig) => {
            if (Array.isArray(modelConfig.elements)) {
                return modelConfig.elements.includes(cmpMeta.tagName);
            }
            return modelConfig.elements === cmpMeta.tagName;
        });
        if (relevantModelConfig) {
            model = `
  model: {
    prop: '${relevantModelConfig.targetAttr}',
    event: '${relevantModelConfig.event}'
  },`;
        }
    }
    if (Array.isArray(cmpMeta.methods) && cmpMeta.methods.length > 0) {
        const relevantMethodConfig = cmpMeta.methods
            .map((method) => `    ${method.name}: createCommonMethod('${method.name}') as ${importTypes}.${tagNameAsPascal}['${method.name}'],`)
            .join('\n');
        methods = `
  methods: {
${relevantMethodConfig}
  },`;
    }
    return `
export const ${tagNameAsPascal} = /*@__PURE__*/ Vue.extend({
${props}
${model}
${methods}
  render: createCommonRender('${cmpMeta.tagName}', [${cmpMeta.events
        .map((e) => `'${e.name}'`)
        .join(', ')}]),
});\n`;
};

async function vueProxyOutput(config, compilerCtx, outputTarget, components) {
    const filteredComponents = getFilteredComponents(outputTarget.excludeComponents, components);
    const rootDir = config.rootDir;
    const pkgData = await readPackageJson(rootDir);
    const finalText = generateProxies(config, filteredComponents, pkgData, outputTarget, rootDir);
    await compilerCtx.fs.writeFile(outputTarget.proxiesFile, finalText);
    await copyResources(config, outputTarget);
}
function getFilteredComponents(excludeComponents = [], cmps) {
    return sortBy(cmps, (cmp) => cmp.tagName).filter((c) => !excludeComponents.includes(c.tagName) && !c.internal);
}
function generateProxies(config, components, pkgData, outputTarget, rootDir) {
    const distTypesDir = path__default["default"].dirname(pkgData.types);
    const dtsFilePath = path__default["default"].join(rootDir, distTypesDir, GENERATED_DTS);
    const componentsTypeFile = relativeImport(outputTarget.proxiesFile, dtsFilePath, ".d.ts");
    const pathToCorePackageLoader = getPathToCorePackageLoader(config, outputTarget);
    const imports = `/* eslint-disable */
/* tslint:disable */
/* auto-generated vue proxies */
import Vue, { PropOptions } from 'vue';
import { createCommonRender, createCommonMethod } from './vue-component-lib/utils';\n`;
    const typeImports = !outputTarget.componentCorePackage
        ? `import type { ${IMPORT_TYPES} } from '${normalizePath(componentsTypeFile)}';\n`
        : `import type { ${IMPORT_TYPES} } from '${normalizePath(outputTarget.componentCorePackage)}';\n`;
    let sourceImports = "";
    let registerCustomElements = "";
    if (outputTarget.includePolyfills &&
        outputTarget.includeDefineCustomElements) {
        sourceImports = `import { ${APPLY_POLYFILLS}, ${REGISTER_CUSTOM_ELEMENTS} } from '${pathToCorePackageLoader}';\n`;
        registerCustomElements = `${APPLY_POLYFILLS}().then(() => ${REGISTER_CUSTOM_ELEMENTS}());`;
    }
    else if (!outputTarget.includePolyfills &&
        outputTarget.includeDefineCustomElements) {
        sourceImports = `
    import * as Default from '${pathToCorePackageLoader}';\n
    export default Default;\n
    `;
    }
    const final = [
        imports,
        typeImports,
        sourceImports,
        registerCustomElements,
        createIgnoredElementsString(components),
        components
            .map(createComponentDefinition(IMPORT_TYPES, outputTarget.componentModels))
            .join("\n"),
    ];
    return final.join("\n") + "\n";
}
function createIgnoredElementsString(components) {
    const ignoredElements = components
        .map((component) => ` '${component.tagName}',`)
        .join("\n");
    return `
const customElementTags: string[] = [
${ignoredElements}
];
Vue.config.ignoredElements = [...Vue.config.ignoredElements, ...customElementTags];\n`;
}
async function copyResources(config, outputTarget) {
    if (!config.sys || !config.sys.copy || !config.sys.glob) {
        throw new Error("stencil is not properly initialized at this step. Notify the developer");
    }
    const srcDirectory = path__default["default"].join(__dirname, "..", "vue-component-lib");
    const destDirectory = path__default["default"].join(path__default["default"].dirname(outputTarget.proxiesFile), "vue-component-lib");
    return config.sys.copy([
        {
            src: srcDirectory,
            dest: destDirectory,
            keepDirStructure: false,
            warn: false,
            ignore: ["**/node_modules/**", "**/dist/**"],
        },
    ], srcDirectory);
}
function getPathToCorePackageLoader(config, outputTarget) {
    var _a;
    const basePkg = outputTarget.componentCorePackage || "";
    const distOutputTarget = (_a = config.outputTargets) === null || _a === void 0 ? void 0 : _a.find((o) => o.type === "dist");
    const distAbsEsmLoaderPath = (distOutputTarget === null || distOutputTarget === void 0 ? void 0 : distOutputTarget.esmLoaderPath) &&
        path__default["default"].isAbsolute(distOutputTarget.esmLoaderPath)
        ? distOutputTarget.esmLoaderPath
        : null;
    const distRelEsmLoaderPath = config.rootDir && distAbsEsmLoaderPath
        ? path__default["default"].relative(config.rootDir, distAbsEsmLoaderPath)
        : null;
    const loaderDir = outputTarget.loaderDir || distRelEsmLoaderPath || DEFAULT_LOADER_DIR;
    return normalizePath(path__default["default"].join(basePkg, loaderDir));
}
const GENERATED_DTS = "components.d.ts";
const IMPORT_TYPES = "Components";
const REGISTER_CUSTOM_ELEMENTS = "defineCustomElements";
const APPLY_POLYFILLS = "applyPolyfills";
const DEFAULT_LOADER_DIR = "/dist/loader";

const vueOutputTarget = (outputTarget) => ({
    type: "custom",
    name: "vue-library",
    validate(config) {
        return normalizeOutputTarget(config, outputTarget);
    },
    async generator(config, compilerCtx, buildCtx) {
        const timespan = buildCtx.createTimeSpan(`generate vue started`, true);
        await vueProxyOutput(config, compilerCtx, outputTarget, buildCtx.components);
        timespan.finish(`generate vue finished`);
    },
});
function normalizeOutputTarget(config, outputTarget) {
    var _a, _b;
    const results = {
        ...outputTarget,
        excludeComponents: outputTarget.excludeComponents || [],
        componentModels: outputTarget.componentModels || [],
        includePolyfills: (_a = outputTarget.includePolyfills) !== null && _a !== void 0 ? _a : true,
        includeDefineCustomElements: (_b = outputTarget.includeDefineCustomElements) !== null && _b !== void 0 ? _b : true,
    };
    if (config.rootDir == null) {
        throw new Error("rootDir is not set and it should be set by stencil itself");
    }
    if (outputTarget.proxiesFile == null) {
        throw new Error("proxiesFile is required");
    }
    if (outputTarget.directivesProxyFile &&
        !path__default["default"].isAbsolute(outputTarget.directivesProxyFile)) {
        results.proxiesFile = normalizePath(path__default["default"].join(config.rootDir, outputTarget.proxiesFile));
    }
    return results;
}

exports.vueOutputTarget = vueOutputTarget;
